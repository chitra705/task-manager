/**
   * @type {any}
   */
static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};
/**
   * @type {any}
   */
static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super();this.options=void 0;this.parsed=void 0;this.skip=void 0;this.stop=void 0;t&&Object.assign(this,t)}inRange(t,e,s){const i=this.options;const{x:n,y:o}=this.getProps(["x","y"],s);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(t,e){return inRange$1(this,t,"x",e)}inYRange(t,e){return inRange$1(this,t,"y",e)}getCenterPoint(t){const{x:e,y:s}=this.getProps(["x","y"],t);return{x:e,y:s}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const s=e&&t.borderWidth||0;return(e+s)*2}draw(t,e){const s=this.options;if(!(this.skip||s.radius<.1)&&T(this,e,this.size(s)/2)){t.strokeStyle=s.borderColor;t.lineWidth=s.borderWidth;t.fillStyle=s.backgroundColor;At(t,s,this.x,this.y)}}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}function getBarBounds(t,e){const{x:s,y:i,base:n,width:o,height:a}=t.getProps(["x","y","base","width","height"],e);let r,l,c,h,d;if(t.horizontal){d=a/2;r=Math.min(s,n);l=Math.max(s,n);c=i-d;h=i+d}else{d=o/2;r=s-d;l=s+d;c=Math.min(i,n);h=Math.max(i,n)}return{left:r,top:c,right:l,bottom:h}}function skipOrLimit(t,e,s,i){return t?0:G(e,s,i)}function parseBorderWidth(t,e,s){const i=t.options.borderWidth;const n=t.borderSkipped;const o=Lt(i);return{t:skipOrLimit(n.top,o.top,0,s),r:skipOrLimit(n.right,o.right,0,e),b:skipOrLimit(n.bottom,o.bottom,0,s),l:skipOrLimit(n.left,o.left,0,e)}}function parseBorderRadius(t,e,s){const{enableBorderRadius:i}=t.getProps(["enableBorderRadius"]);const o=t.options.borderRadius;const a=Tt(o);const r=Math.min(e,s);const l=t.borderSkipped;const c=i||n(o);return{topLeft:skipOrLimit(!c||l.top||l.left,a.topLeft,0,r),topRight:skipOrLimit(!c||l.top||l.right,a.topRight,0,r),bottomLeft:skipOrLimit(!c||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:skipOrLimit(!c||l.bottom||l.right,a.bottomRight,0,r)}}function boundingRects(t){const e=getBarBounds(t);const s=e.right-e.left;const i=e.bottom-e.top;const n=parseBorderWidth(t,s/2,i/2);const o=parseBorderRadius(t,s/2,i/2);return{outer:{x:e.left,y:e.top,w:s,h:i,radius:o},inner:{x:e.left+n.l,y:e.top+n.t,w:s-n.l-n.r,h:i-n.t-n.b,radius:{topLeft:Math.max(0,o.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,o.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,o.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,o.bottomRight-Math.max(n.b,n.r))}}}}function inRange(t,e,s,i){const n=e===null;const o=s===null;const a=n&&o;const r=t&&!a&&getBarBounds(t,i);return r&&(n||yt(e,r.left,r.right))&&(o||yt(s,r.top,r.bottom))}function hasRadius(t){return t.topLeft||t.topRight||t.bottomLeft||t.bottomRight}function addNormalRectPath(t,e){t.rect(e.x,e.y,e.w,e.h)}function inflateRect(t,e,s={}){const i=t.x!==s.x?-e:0;const n=t.y!==s.y?-e:0;const o=(t.x+t.w!==s.x+s.w?e:0)-i;const a=(t.y+t.h!==s.y+s.h?e:0)-n;return{x:t.x+i,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}class BarElement extends Element{static id="bar";static defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super();this.options=void 0;this.horizontal=void 0;this.base=void 0;this.width=void 0;this.height=void 0;this.inflateAmount=void 0;t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:s,backgroundColor:i}}=this;const{inner:n,outer:o}=boundingRects(this);const a=hasRadius(o.radius)?Ot:addNormalRectPath;t.save();if(o.w!==n.w||o.h!==n.h){t.beginPath();a(t,inflateRect(o,e,n));t.clip();a(t,inflateRect(n,-e,o));t.fillStyle=s;t.fill("evenodd")}t.beginPath();a(t,inflateRect(n,e));t.fillStyle=i;t.fill();t.restore()}inRange(t,e,s){return inRange(this,t,e,s)}inXRange(t,e){return inRange(this,t,null,e)}inYRange(t,e){return inRange(this,null,t,e)}getCenterPoint(t){const{x:e,y:s,base:i,horizontal:n}=this.getProps(["x","y","base","horizontal"],t);return{x:n?(e+i)/2:e,y:n?s:(s+i)/2}}getRange(t){return t==="x"?this.width/2:this.height/2}}var be=Object.freeze({__proto__:null,ArcElement:ArcElement,BarElement:BarElement,LineElement:LineElement,PointElement:PointElement});const _e=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 159, 64)","rgb(255, 205, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(201, 203, 207)"];const ye=_e.map((t=>t.replace("rgb(","rgba(").replace(")",", 0.5)")));function getBorderColor(t){return _e[t%_e.length]}function getBackgroundColor(t){return ye[t%ye.length]}function colorizeDefaultDataset(t,e){t.borderColor=getBorderColor(e);t.backgroundColor=getBackgroundColor(e);return++e}function colorizeDoughnutDataset(t,e){t.backgroundColor=t.data.map((()=>getBorderColor(e++)));return e}function colorizePolarAreaDataset(t,e){t.backgroundColor=t.data.map((()=>getBackgroundColor(e++)));return e}function getColorizer(t){let e=0;return(s,i)=>{const n=t.getDatasetMeta(i).controller;n instanceof DoughnutController?e=colorizeDoughnutDataset(s,e):n instanceof PolarAreaController?e=colorizePolarAreaDataset(s,e):n&&(e=colorizeDefaultDataset(s,e))}}function containsColorsDefinitions(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return true;return false}function containsColorsDefinition(t){return t&&(t.borderColor||t.backgroundColor)}var ve={id:"colors",defaults:{enabled:true,forceOverride:false},beforeLayout(t,e,s){if(!s.enabled)return;const{data:{datasets:i},options:n}=t.config;const{elements:o}=n;if(!s.forceOverride&&(containsColorsDefinitions(i)||containsColorsDefinition(n)||o&&containsColorsDefinitions(o)))return;const a=getColorizer(t);i.forEach(a)}};function lttbDecimation(t,e,s,i,n){const o=n.samples||i;if(o>=s)return t.slice(e,e+s);const a=[];const r=(s-2)/(o-2);let l=0;const c=e+s-1;let h=e;let d,u,g,f,p;a[l++]=t[h];for(d=0;d<o-2;d++){let i=0;let n=0;let o;const c=Math.floor((d+1)*r)+1+e;const m=Math.min(Math.floor((d+2)*r)+1,s)+e;const x=m-c;for(o=c;o<m;o++){i+=t[o].x;n+=t[o].y}i/=x;n/=x;const b=Math.floor(d*r)+1+e;const _=Math.min(Math.floor((d+1)*r)+1,s)+e;const{x:y,y:v}=t[h];g=f=-1;for(o=b;o<_;o++){f=.5*Math.abs((y-i)*(t[o].y-v)-(y-t[o].x)*(n-v));if(f>g){g=f;u=t[o];p=o}}a[l++]=u;h=p}a[l++]=t[c];return a}function minMaxDecimation(t,e,s,i){let n=0;let o=0;let a,r,l,c,h,d,u,g,f,p;const x=[];const b=e+s-1;const _=t[e].x;const y=t[b].x;const v=y-_;for(a=e;a<e+s;++a){r=t[a];l=(r.x-_)/v*i;c=r.y;const e=l|0;if(e===h){if(c<f){f=c;d=a}else if(c>p){p=c;u=a}n=(o*n+r.x)/++o}else{const s=a-1;if(!m(d)&&!m(u)){const e=Math.min(d,u);const i=Math.max(d,u);e!==g&&e!==s&&x.push({...t[e],x:n});i!==g&&i!==s&&x.push({...t[i],x:n})}a>0&&s!==g&&x.push(t[s]);x.push(r);h=e;o=0;f=p=c;d=u=g=a}}return x}function cleanDecimatedDataset(t){if(t._decimated){const e=t._data;delete t._decimated;delete t._data;Object.defineProperty(t,"data",{configurable:true,enumerable:true,writable:true,value:e})}}function cleanDecimatedData(t){t.data.datasets.forEach((t=>{cleanDecimatedDataset(t)}))}function getStartAndCountOfVisiblePointsSimplified(t,e){const s=e.length;let i=0;let n;const{iScale:o}=t;const{min:a,max:r,minDefined:l,maxDefined:c}=o.getUserBounds();l&&(i=G(L(e,o.axis,a).lo,0,s-1));n=c?G(L(e,o.axis,r).hi+1,i,s)-i:s-i;return{start:i,count:n}}var ke={id:"decimation",defaults:{algorithm:"min-max",enabled:false},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled){cleanDecimatedData(t);return}const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e;const l=t.getDatasetMeta(o);const c=a||e.data;if(s([r,t.options.indexAxis])==="y")return;if(!l.controller.supportsDecimation)return;const h=t.scales[l.xAxisID];if(h.type!=="linear"&&h.type!=="time")return;if(t.options.parsing)return;let{start:d,count:u}=getStartAndCountOfVisiblePointsSimplified(l,c);const g=i.threshold||4*n;if(u<=g){cleanDecimatedDataset(e);return}if(m(a)){e._data=c;delete e.data;Object.defineProperty(e,"data",{configurable:true,enumerable:true,get:function(){return this._decimated},set:function(t){this._data=t}})}let f;switch(i.algorithm){case"lttb":f=lttbDecimation(c,d,u,n,i);break;case"min-max":f=minMaxDecimation(c,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){cleanDecimatedData(t)}};function _segments(t,e,s){const i=t.segments;const n=t.points;const o=e.points;const a=[];for(const t of i){let{start:i,end:r}=t;r=_findSegmentEnd(i,r,n);const l=_getBounds(s,n[i],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[i],end:n[r]});continue}const c=Pt(e,l);for(const e of c){const i=_getBounds(s,o[e.start],o[e.end],e.loop);const r=Et(t,n,i);for(const t of r)a.push({source:t,target:e,start:{[s]:_getEdge(l,i,"start",Math.max)},end:{[s]:_getEdge(l,i,"end",Math.min)}})}}return a}function _getBounds(t,e,s,i){if(i)return;let n=e[t];let o=s[t];if(t==="angle"){n=It(n);o=It(o)}return{property:t,start:n,end:o}}function _pointsFromSegments(t,e){const{x:s=null,y:i=null}=t||{};const n=e.points;const o=[];e.segments.forEach((({start:t,end:e})=>{e=_findSegmentEnd(t,e,n);const a=n[t];const r=n[e];if(i!==null){o.push({x:a.x,y:i});o.push({x:r.x,y:i})}else if(s!==null){o.push({x:s,y:a.y});o.push({x:s,y:r.y})}}));return o}function _findSegmentEnd(t,e,s){for(;e>t;e--){const t=s[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function _getEdge(t,e,s,i){return t&&e?i(t[s],e[s]):t?t[s]:e?e[s]:0}function _createBoundaryLine(t,e){let s=[];let i=false;if(a(t)){i=true;s=t}else s=_pointsFromSegments(t,e);return s.length?new LineElement({points:s,options:{tension:0},_loop:i,_fullLoop:i}):null}function _shouldApplyFill(t){return t&&t.fill!==false}function _resolveTarget(t,e,s){const i=t[e];let n=i.fill;const o=[e];let a;if(!s)return n;while(n!==false&&o.indexOf(n)===-1){if(!r(n))return n;a=t[n];if(!a)return false;if(a.visible)return n;o.push(n);n=a.fill}return false}function _decodeFill(t,e,s){const i=parseFillOption(t);if(n(i))return!isNaN(i.value)&&i;let o=parseFloat(i);return r(o)&&Math.floor(o)===o?decodeTargetIndex(i[0],e,o,s):["origin","start","end","stack","shape"].indexOf(i)>=0&&i}function decodeTargetIndex(t,e,s,i){t!=="-"&&t!=="+"||(s=e+s);return!(s===e||s<0||s>=i)&&s}function _getTargetPixel(t,e){let s=null;t==="start"?s=e.bottom:t==="end"?s=e.top:n(t)?s=e.getPixelForValue(t.value):e.getBasePixel&&(s=e.getBasePixel());return s}function _getTargetValue(t,e,s){let i;i=t==="start"?s:t==="end"?e.options.reverse?e.min:e.max:n(t)?t.value:e.getBaseValue();return i}function parseFillOption(t){const e=t.options;const s=e.fill;let i=h(s&&s.target,s);i===void 0&&(i=!!e.backgroundColor);return i!==false&&i!==null&&(i===true?"origin":i)}function _buildStackLine(t){const{scale:e,index:s,line:i}=t;const n=[];const o=i.segments;const a=i.points;const r=getLinesBelow(e,s);r.push(_createBoundaryLine({x:null,y:e.bottom},i));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)addPointsBelow(n,a[t],r)}return new LineElement({points:n,options:{}})}function getLinesBelow(t,e){const s=[];const i=t.getMatchingVisibleMetas("line");for(let t=0;t<i.length;t++){const n=i[t];if(n.index===e)break;n.hidden||s.unshift(n.dataset)}return s}function addPointsBelow(t,e,s){const i=[];for(let n=0;n<s.length;n++){const o=s[n];const{first:a,last:r,point:l}=findPoint(o,e,"x");if(!(!l||a&&r))if(a)i.unshift(l);else{t.push(l);if(!r)break}}t.push(...i)}function findPoint(t,e,s){const i=t.interpolate(e,s);if(!i)return{};const n=i[s];const o=t.segments;const a=t.points;let r=false;let l=false;for(let t=0;t<o.length;t++){const e=o[t];const i=a[e.start][s];const c=a[e.end][s];if(yt(n,i,c)){r=n===i;l=n===c;break}}return{first:r,last:l,point:i}}class simpleArc{constructor(t){this.x=t.x;this.y=t.y;this.radius=t.radius}pathSegment(t,e,s){const{x:i,y:n,radius:o}=this;e=e||{start:0,end:x};t.arc(i,n,o,e.end,e.start,true);return!s.bounds}interpolate(t){const{x:e,y:s,radius:i}=this;const n=t.angle;return{x:e+Math.cos(n)*i,y:s+Math.sin(n)*i,angle:n}}}function _getTarget(t){const{chart:e,fill:s,line:i}=t;if(r(s))return getLineByIndex(e,s);if(s==="stack")return _buildStackLine(t);if(s==="shape")return true;const n=computeBoundary(t);return n instanceof simpleArc?n:_createBoundaryLine(n,i)}function getLineByIndex(t,e){const s=t.getDatasetMeta(e);const i=s&&t.isDatasetVisible(e);return i?s.dataset:null}function computeBoundary(t){const e=t.scale||{};return e.getPointPositionForValue?computeCircularBoundary(t):computeLinearBoundary(t)}function computeLinearBoundary(t){const{scale:e={},fill:s}=t;const i=_getTargetPixel(s,e);if(r(i)){const t=e.isHorizontal();return{x:t?i:null,y:t?null:i}}return null}function computeCircularBoundary(t){const{scale:e,fill:s}=t;const i=e.options;const n=e.getLabels().length;const o=i.reverse?e.max:e.min;const a=_getTargetValue(s,e,o);const r=[];if(i.grid.circular){const t=e.getPointPositionForValue(0,o);return new simpleArc({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(a)})}for(let t=0;t<n;++t)r.push(e.getPointPositionForValue(t,a));return r}function _drawfill(t,e,s){const i=_getTarget(e);const{line:n,scale:o,axis:a}=e;const r=n.options;const l=r.fill;const c=r.backgroundColor;const{above:h=c,below:d=c}=l||{};if(i&&n.points.length){tt(t,s);doFill(t,{line:n,target:i,above:h,below:d,area:s,scale:o,axis:a});st(t)}}function doFill(t,e){const{line:s,target:i,above:n,below:o,area:a,scale:r}=e;const l=s._loop?"angle":e.axis;t.save();if(l==="x"&&o!==n){clipVertical(t,i,a.top);fill(t,{line:s,target:i,color:n,scale:r,property:l});t.restore();t.save();clipVertical(t,i,a.bottom)}fill(t,{line:s,target:i,color:o,scale:r,property:l});t.restore()}function clipVertical(t,e,s){const{segments:i,points:n}=e;let o=true;let a=false;t.beginPath();for(const r of i){const{start:i,end:l}=r;const c=n[i];const h=n[_findSegmentEnd(i,l,n)];if(o){t.moveTo(c.x,c.y);o=false}else{t.lineTo(c.x,s);t.lineTo(c.x,c.y)}a=!!e.pathSegment(t,r,{move:a});a?t.closePath():t.lineTo(h.x,s)}t.lineTo(e.first().x,s);t.closePath();t.clip()}function fill(t,e){const{line:s,target:i,property:n,color:o,scale:a}=e;const r=_segments(s,i,n);for(const{source:e,target:l,start:c,end:h}of r){const{style:{backgroundColor:r=o}={}}=e;const d=i!==true;t.save();t.fillStyle=r;clipBounds(t,a,d&&_getBounds(n,c,h));t.beginPath();const u=!!s.pathSegment(t,e);let g;if(d){u?t.closePath():interpolatedLineTo(t,i,h,n);const e=!!i.pathSegment(t,l,{move:u,reverse:true});g=u&&e;g||interpolatedLineTo(t,i,c,n)}t.closePath();t.fill(g?"evenodd":"nonzero");t.restore()}}function clipBounds(t,e,s){const{top:i,bottom:n}=e.chart.chartArea;const{property:o,start:a,end:r}=s||{};if(o==="x"){t.beginPath();t.rect(a,i,r-a,n-i);t.clip()}}function interpolatedLineTo(t,e,s,i){const n=e.interpolate(s,i);n&&t.lineTo(n.x,n.y)}var Me={id:"filler",afterDatasetsUpdate(t,e,s){const i=(t.data.datasets||[]).length;const n=[];let o,a,r,l;for(a=0;a<i;++a){o=t.getDatasetMeta(a);r=o.dataset;l=null;r&&r.options&&r instanceof LineElement&&(l={visible:t.isDatasetVisible(a),index:a,fill:_decodeFill(r,a,i),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r});o.$filler=l;n.push(l)}for(a=0;a<i;++a){l=n[a];l&&l.fill!==false&&(l.fill=_resolveTarget(n,a,s.propagate))}},beforeDraw(t,e,s){const i=s.drawTime==="beforeDraw";const n=t.getSortedVisibleDatasetMetas();const o=t.chartArea;for(let e=n.length-1;e>=0;--e){const s=n[e].$filler;if(s){s.line.updateControlPoints(o,s.axis);i&&s.fill&&_drawfill(t.ctx,s,o)}}},beforeDatasetsDraw(t,e,s){if(s.drawTime!=="beforeDatasetsDraw")return;const i=t.getSortedVisibleDatasetMetas();for(let e=i.length-1;e>=0;--e){const s=i[e].$filler;_shouldApplyFill(s)&&_drawfill(t.ctx,s,t.chartArea)}},beforeDatasetDraw(t,e,s){const i=e.meta.$filler;_shouldApplyFill(i)&&s.drawTime==="beforeDatasetDraw"&&_drawfill(t.ctx,i,t.chartArea)},defaults:{propagate:true,drawTime:"beforeDatasetDraw"}};const getBoxSize=(t,e)=>{let{boxHeight:s=e,boxWidth:i=e}=t;if(t.usePointStyle){s=Math.min(s,e);i=t.pointStyleWidth||Math.min(i,e)}return{boxWidth:i,boxHeight:s,itemHeight:Math.max(e,s)}};const itemsEqual=(t,e)=>t!==null&&e!==null&&t.datasetIndex===e.datasetIndex&&t.index===e.index;class Legend extends Element{constructor(t){super();this._added=false;this.legendHitBoxes=[];this._hoveredItem=null;this.doughnutMode=false;this.chart=t.chart;this.options=t.options;this.ctx=t.ctx;this.legendItems=void 0;this.columnSizes=void 0;this.lineWidths=void 0;this.maxHeight=void 0;this.maxWidth=void 0;this.top=void 0;this.bottom=void 0;this.left=void 0;this.right=void 0;this.height=void 0;this.width=void 0;this._margins=void 0;this.position=void 0;this.weight=void 0;this.fullSize=void 0}update(t,e,s){this.maxWidth=t;this.maxHeight=e;this._margins=s;this.setDimensions();this.buildLabels();this.fit()}setDimensions(){if(this.isHorizontal()){this.width=this.maxWidth;this.left=this._margins.left;this.right=this.width}else{this.height=this.maxHeight;this.top=this._margins.top;this.bottom=this.height}}buildLabels(){const t=this.options.labels||{};let e=X(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data))));t.sort&&(e=e.sort(((e,s)=>t.sort(e,s,this.chart.data))));this.options.reverse&&e.reverse();this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const s=t.labels;const i=j(s.font);const n=i.size;const o=this._computeTitleHeight();const{boxWidth:a,itemHeight:r}=getBoxSize(s,n);let l,c;e.font=i.string;if(this.isHorizontal()){l=this.maxWidth;c=this._fitRows(o,n,a,r)+10}else{c=this.maxHeight;l=this._fitCols(o,i,a,r)+10}this.width=Math.min(l,t.maxWidth||this.maxWidth);this.height=Math.min(c,t.maxHeight||this.maxHeight)}_fitRows(t,e,s,i){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this;const r=this.legendHitBoxes=[];const l=this.lineWidths=[0];const c=i+a;let h=t;n.textAlign="left";n.textBaseline="middle";let d=-1;let u=-c;this.legendItems.forEach(((t,g)=>{const f=s+e/2+n.measureText(t.text).width;if(g===0||l[l.length-1]+f+2*a>o){h+=c;l[l.length-(g>0?0:1)]=0;u+=c;d++}r[g]={left:0,top:u,row:d,width:f,height:i};l[l.length-1]+=f+a}));return h}_fitCols(t,e,s,i){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this;const r=this.legendHitBoxes=[];const l=this.columnSizes=[];const c=o-t;let h=a;let d=0;let u=0;let g=0;let f=0;this.legendItems.forEach(((t,o)=>{const{itemWidth:p,itemHeight:m}=calculateItemSize(s,e,n,t,i);if(o>0&&u+m+2*a>c){h+=d+a;l.push({width:d,height:u});g+=d+a;f++;d=u=0}r[o]={left:g,top:u,col:f,width:p,height:m};d=Math.max(d,p);u+=m+a}));h+=d;l.push({width:d,height:u});return h}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight();const{legendHitBoxes:e,options:{align:s,labels:{padding:i},rtl:n}}=this;const o=Rt(n,this.left,this.width);if(this.isHorizontal()){let n=0;let a=U(s,this.left+i,this.right-this.lineWidths[n]);for(const r of e){if(n!==r.row){n=r.row;a=U(s,this.left+i,this.right-this.lineWidths[n])}r.top+=this.top+t+i;r.left=o.leftForLtr(o.x(a),r.width);a+=r.width+i}}else{let n=0;let a=U(s,this.top+t+i,this.bottom-this.columnSizes[n].height);for(const r of e){if(r.col!==n){n=r.col;a=U(s,this.top+t+i,this.bottom-this.columnSizes[n].height)}r.top=a;r.left+=this.left+i;r.left=o.leftForLtr(o.x(r.left),r.width);a+=r.height+i}}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const t=this.ctx;tt(t,this);this._draw();st(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:s,ctx:i}=this;const{align:n,labels:a}=t;const r=o.color;const l=Rt(t.rtl,this.left,this.width);const c=j(a.font);const{padding:d}=a;const u=c.size;const g=u/2;let f;this.drawTitle();i.textAlign=l.textAlign("left");i.textBaseline="middle";i.lineWidth=.5;i.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:x}=getBoxSize(a,u);const drawLegendBox=function(t,e,s){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;i.save();const n=h(s.lineWidth,1);i.fillStyle=h(s.fillStyle,r);i.lineCap=h(s.lineCap,"butt");i.lineDashOffset=h(s.lineDashOffset,0);i.lineJoin=h(s.lineJoin,"miter");i.lineWidth=n;i.strokeStyle=h(s.strokeStyle,r);i.setLineDash(h(s.lineDash,[]));if(a.usePointStyle){const o={radius:m*Math.SQRT2/2,pointStyle:s.pointStyle,rotation:s.rotation,borderWidth:n};const r=l.xPlus(t,p/2);const c=e+g;Ft(i,o,r,c,a.pointStyleWidth&&p)}else{const o=e+Math.max((u-m)/2,0);const a=l.leftForLtr(t,p);const r=Tt(s.borderRadius);i.beginPath();Object.values(r).some((t=>t!==0))?Ot(i,{x:a,y:o,w:p,h:m,radius:r}):i.rect(a,o,p,m);i.fill();n!==0&&i.stroke()}i.restore()};const fillText=function(t,e,s){et(i,s.text,t,e+x/2,c,{strikethrough:s.hidden,textAlign:l.textAlign(s.textAlign)})};const b=this.isHorizontal();const _=this._computeTitleHeight();f=b?{x:U(n,this.left+d,this.right-s[0]),y:this.top+d+_,line:0}:{x:this.left+d,y:U(n,this.top+_+d,this.bottom-e[0].height),line:0};Bt(this.ctx,t.textDirection);const y=x+d;this.legendItems.forEach(((o,r)=>{i.strokeStyle=o.fontColor;i.fillStyle=o.fontColor;const h=i.measureText(o.text).width;const u=l.textAlign(o.textAlign||(o.textAlign=a.textAlign));const m=p+g+h;let x=f.x;let v=f.y;l.setWidth(this.width);if(b){if(r>0&&x+m+d>this.right){v=f.y+=y;f.line++;x=f.x=U(n,this.left+d,this.right-s[f.line])}}else if(r>0&&v+y>this.bottom){x=f.x=x+e[f.line].width+d;f.line++;v=f.y=U(n,this.top+_+d,this.bottom-e[f.line].height)}const k=l.x(x);drawLegendBox(k,v,o);x=zt(u,x+p+g,b?x+m:this.right,t.rtl);fillText(l.x(x),v,o);if(b)f.x+=m+d;else if(typeof o.text!=="string"){const t=c.lineHeight;f.y+=calculateLegendItemHeight(o,t)+d}else f.y+=y}));Vt(this.ctx,t.textDirection)}drawTitle(){const t=this.options;const e=t.title;const s=j(e.font);const i=I(e.padding);if(!e.display)return;const n=Rt(t.rtl,this.left,this.width);const o=this.ctx;const a=e.position;const r=s.size/2;const l=i.top+r;let c;let h=this.left;let d=this.width;if(this.isHorizontal()){d=Math.max(...this.lineWidths);c=this.top+l;h=U(t.align,h,this.right-d)}else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);c=l+U(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=U(a,h,h+d);o.textAlign=n.textAlign($(a));o.textBaseline="middle";o.strokeStyle=e.color;o.fillStyle=e.color;o.font=s.string;et(o,e.text,u,c,s)}_computeTitleHeight(){const t=this.options.title;const e=j(t.font);const s=I(t.padding);return t.display?e.lineHeight+s.height:0}_getLegendItemAt(t,e){let s,i,n;if(yt(t,this.left,this.right)&&yt(e,this.top,this.bottom)){n=this.legendHitBoxes;for(s=0;s<n.length;++s){i=n[s];if(yt(t,i.left,i.left+i.width)&&yt(e,i.top,i.top+i.height))return this.legendItems[s]}}return null}handleEvent(t){const e=this.options;if(!isListened(t.type,e))return;const s=this._getLegendItemAt(t.x,t.y);if(t.type==="mousemove"||t.type==="mouseout"){const i=this._hoveredItem;const n=itemsEqual(i,s);i&&!n&&X(e.onLeave,[t,i,this],this);this._hoveredItem=s;s&&!n&&X(e.onHover,[t,s,this],this)}else s&&X(e.onClick,[t,s,this],this)}}function calculateItemSize(t,e,s,i,n){const o=calculateItemWidth(i,t,e,s);const a=calculateItemHeight(n,i,e.lineHeight);return{itemWidth:o,itemHeight:a}}function calculateItemWidth(t,e,s,i){let n=t.text;n&&typeof n!=="string"&&(n=n.reduce(((t,e)=>t.length>e.length?t:e)));return e+s.size/2+i.measureText(n).width}function calculateItemHeight(t,e,s){let i=t;typeof e.text!=="string"&&(i=calculateLegendItemHeight(e,s));return i}function calculateLegendItemHeight(t,e){const s=t.text?t.text.length:0;return e*s}function isListened(t,e){return!(t!=="mousemove"&&t!=="mouseout"||!e.onHover&&!e.onLeave)||!(!e.onClick||t!=="click"&&t!=="mouseup")}var Se={id:"legend",_element:Legend,start(t,e,s){const i=t.legend=new Legend({ctx:t.ctx,options:s,chart:t});oe.configure(t,i,s);oe.addBox(t,i)},stop(t){oe.removeBox(t,t.legend);delete t.legend},beforeUpdate(t,e,s){const i=t.legend;oe.configure(t,i,s);i.options=s},afterUpdate(t){const e=t.legend;e.buildLabels();e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:true,position:"top",align:"center",fullSize:true,reverse:false,weight:1e3,onClick(t,e,s){const i=e.datasetIndex;const n=s.chart;if(n.isDatasetVisible(i)){n.hide(i);e.hidden=true}else{n.show(i);e.hidden=false}},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets;const{labels:{usePointStyle:s,pointStyle:i,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(s?0:void 0);const c=I(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(c.width+c.height)/4,strokeStyle:l.borderColor,pointStyle:i||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&&(r||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:false,position:"center",text:""}},descriptors:{_scriptable:t=>!t.startsWith("on"),labels:{_scriptable:t=>!["generateLabels","filter","sort"].includes(t)}}};class Title extends Element{constructor(t){super();this.chart=t.chart;this.options=t.options;this.ctx=t.ctx;this._padding=void 0;this.top=void 0;this.bottom=void 0;this.left=void 0;this.right=void 0;this.width=void 0;this.height=void 0;this.position=void 0;this.weight=void 0;this.fullSize=void 0}update(t,e){const s=this.options;this.left=0;this.top=0;if(!s.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=t;this.height=this.bottom=e;const i=a(s.text)?s.text.length:1;this._padding=I(s.padding);const n=i*j(s.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=n:this.width=n}isHorizontal(){const t=this.options.position;return t==="top"||t==="bottom"}_drawArgs(t){const{top:e,left:s,bottom:i,right:n,options:o}=this;const a=o.align;let r=0;let l,c,h;if(this.isHorizontal()){c=U(a,s,n);h=e+t;l=n-s}else{if(o.position==="left"){c=s+t;h=U(a,i,e);r=y*-.5}else{c=n-t;h=U(a,e,i);r=y*.5}l=i-e}return{titleX:c,titleY:h,maxWidth:l,rotation:r}}draw(){const t=this.ctx;const e=this.options;if(!e.display)return;const s=j(e.font);const i=s.lineHeight;const n=i/2+this._padding.top;const{titleX:o,titleY:a,maxWidth:r,rotation:l}=this._drawArgs(n);et(t,e.text,0,0,s,{color:e.color,maxWidth:r,rotation:l,textAlign:$(e.align),textBaseline:"middle",translation:[o,a]})}}function createTitle(t,e){const s=new Title({ctx:t.ctx,options:e,chart:t});oe.configure(t,s,e);oe.addBox(t,s);t.titleBlock=s}var we={id:"title",_element:Title,start(t,e,s){createTitle(t,s)},stop(t){const e=t.titleBlock;oe.removeBox(t,e);delete t.titleBlock},beforeUpdate(t,e,s){const i=t.titleBlock;oe.configure(t,i,s);i.options=s},defaults:{align:"center",display:false,font:{weight:"bold"},fullSize:true,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:true,_indexable:false}};const De=new WeakMap;var Ce={id:"subtitle",start(t,e,s){const i=new Title({ctx:t.ctx,options:s,chart:t});oe.configure(t,i,s);oe.addBox(t,i);De.set(t,i)},stop(t){oe.removeBox(t,De.get(t));De.delete(t)},beforeUpdate(t,e,s){const i=De.get(t);oe.configure(t,i,s);i.options=s},defaults:{align:"center",display:false,font:{weight:"normal"},fullSize:true,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:true,_indexable:false}};const Pe={average(t){if(!t.length)return false;let e,s;let i=new Set;let n=0;let o=0;for(e=0,s=t.length;e<s;++e){const s=t[e].element;if(s&&s.hasValue()){const t=s.tooltipPosition();i.add(t.x);n+=t.y;++o}}const a=[...i].reduce(((t,e)=>t+e))/i.size;return{x:a,y:n/o}},nearest(t,e){if(!t.length)return false;let s=e.x;let i=e.y;let n=Number.POSITIVE_INFINITY;let o,a,r;for(o=0,a=t.length;o<a;++o){const s=t[o].element;if(s&&s.hasValue()){const t=s.getCenterPoint();const i=Wt(e,t);if(i<n){n=i;r=s}}}if(r){const t=r.tooltipPosition();s=t.x;i=t.y}return{x:s,y:i}}};function pushOrConcat(t,e){e&&(a(e)?Array.prototype.push.apply(t,e):t.push(e));return t}function splitNewlines(t){return(typeof t==="string"||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function createTooltipItem(t,e){const{element:s,datasetIndex:i,index:n}=e;const o=t.getDatasetMeta(i).controller;const{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[i].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:i,element:s}}function getTooltipSize(t,e){const s=t.chart.ctx;const{body:i,footer:n,title:o}=t;const{boxWidth:a,boxHeight:r}=e;const l=j(e.bodyFont);const c=j(e.titleFont);const h=j(e.footerFont);const d=o.length;const u=n.length;const g=i.length;const f=I(e.padding);let p=f.height;let m=0;let x=i.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);x+=t.beforeBody.length+t.afterBody.length;d&&(p+=d*c.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom);if(x){const t=e.displayColors?Math.max(r,l.lineHeight):l.lineHeight;p+=g*t+(x-g)*l.lineHeight+(x-1)*e.bodySpacing}u&&(p+=e.footerMarginTop+u*h.lineHeight+(u-1)*e.footerSpacing);let b=0;const maxLineWidth=function(t){m=Math.max(m,s.measureText(t).width+b)};s.save();s.font=c.string;R(t.title,maxLineWidth);s.font=l.string;R(t.beforeBody.concat(t.afterBody),maxLineWidth);b=e.displayColors?a+2+e.boxPadding:0;R(i,(t=>{R(t.before,maxLineWidth);R(t.lines,maxLineWidth);R(t.after,maxLineWidth)}));b=0;s.font=h.string;R(t.footer,maxLineWidth);s.restore();m+=f.width;return{width:m,height:p}}function determineYAlign(t,e){const{y:s,height:i}=e;return s<i/2?"top":s>t.height-i/2?"bottom":"center"}function doesNotFitWithAlign(t,e,s,i){const{x:n,width:o}=i;const a=s.caretSize+s.caretPadding;return t==="left"&&n+o+a>e.width||(t==="right"&&n-o-a<0||void 0)}function determineXAlign(t,e,s,i){const{x:n,width:o}=s;const{width:a,chartArea:{left:r,right:l}}=t;let c="center";i==="center"?c=n<=(r+l)/2?"left":"right":n<=o/2?c="left":n>=a-o/2&&(c="right");doesNotFitWithAlign(c,t,e,s)&&(c="center");return c}function determineAlignment(t,e,s){const i=s.yAlign||e.yAlign||determineYAlign(t,s);return{xAlign:s.xAlign||e.xAlign||determineXAlign(t,e,s,i),yAlign:i}}function alignX(t,e){let{x:s,width:i}=t;e==="right"?s-=i:e==="center"&&(s-=i/2);return s}function alignY(t,e,s){let{y:i,height:n}=t;e==="top"?i+=s:i-=e==="bottom"?n+s:n/2;return i}function getBackgroundPoint(t,e,s,i){const{caretSize:n,caretPadding:o,cornerRadius:a}=t;const{xAlign:r,yAlign:l}=s;const c=n+o;const{topLeft:h,topRight:d,bottomLeft:u,bottomRight:g}=Tt(a);let f=alignX(e,r);const p=alignY(e,l,c);l==="center"?r==="left"?f+=c:r==="right"&&(f-=c):r==="left"?f-=Math.max(h,u)+n:r==="right"&&(f+=Math.max(d,g)+n);return{x:G(f,0,i.width-e.width),y:G(p,0,i.height-e.height)}}function getAlignedX(t,e,s){const i=I(s.padding);return e==="center"?t.x+t.width/2:e==="right"?t.x+t.width-i.right:t.x+i.left}function getBeforeAfterBodyLines(t){return pushOrConcat([],splitNewlines(t))}function createTooltipContext(t,e,s){return c(t,{tooltip:e,tooltipItems:s,type:"tooltip"})}function overrideCallbacks(t,e){const s=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return s?t.override(s):t}const Ae={beforeTitle:Nt,title(t){if(t.length>0){const e=t[0];const s=e.chart.data.labels;const i=s?s.length:0;if(this&&this.options&&this.options.mode==="dataset")return e.dataset.label||"";if(e.label)return e.label;if(i>0&&e.dataIndex<i)return s[e.dataIndex]}return""},afterTitle:Nt,beforeBody:Nt,beforeLabel:Nt,label(t){if(this&&this.options&&this.options.mode==="dataset")return t.label+": "+t.formattedValue||t.formattedValue;let e=t.dataset.label||"";e&&(e+=": ");const s=t.formattedValue;m(s)||(e+=s);return e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex);const s=e.controller.getStyle(t.dataIndex);return{borderColor:s.borderColor,backgroundColor:s.backgroundColor,borderWidth:s.borderWidth,borderDash:s.borderDash,borderDashOffset:s.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex);const s=e.controller.getStyle(t.dataIndex);return{pointStyle:s.pointStyle,rotation:s.rotation}},afterLabel:Nt,afterBody:Nt,beforeFooter:Nt,footer:Nt,afterFooter:Nt};function invokeCallbackWithFallback(t,e,s,i){const n=t[e].call(s,i);return typeof n==="undefined"?Ae[e].call(s,i):n}class Tooltip extends Element{static positioners=Pe;constructor(t){super();this.opacity=0;this._active=[];this._eventPosition=void 0;this._size=void 0;this._cachedAnimations=void 0;this._tooltipItems=[];this.$animations=void 0;this.$context=void 0;this.chart=t.chart;this.options=t.options;this.dataPoints=void 0;this.title=void 0;this.beforeBody=void 0;this.body=void 0;this.afterBody=void 0;this.footer=void 0;this.xAlign=void 0;this.yAlign=void 0;this.x=void 0;this.y=void 0;this.height=void 0;this.width=void 0;this.caretX=void 0;this.caretY=void 0;this.labelColors=void 0;this.labelPointStyles=void 0;this.labelTextColors=void 0}initialize(t){this.options=t;this._cachedAnimations=void 0;this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart;const s=this.options.setContext(this.getContext());const i=s.enabled&&e.options.animation&&s.animations;const n=new Animations(this.chart,i);i._cacheable&&(this._cachedAnimations=Object.freeze(n));return n}getContext(){return this.$context||(this.$context=createTooltipContext(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:s}=e;const i=invokeCallbackWithFallback(s,"beforeTitle",this,t);const n=invokeCallbackWithFallback(s,"title",this,t);const o=invokeCallbackWithFallback(s,"afterTitle",this,t);let a=[];a=pushOrConcat(a,splitNewlines(i));a=pushOrConcat(a,splitNewlines(n));a=pushOrConcat(a,splitNewlines(o));return a}getBeforeBody(t,e){return getBeforeAfterBodyLines(invokeCallbackWithFallback(e.callbacks,"beforeBody",this,t))}getBody(t,e){const{callbacks:s}=e;const i=[];R(t,(t=>{const e={before:[],lines:[],after:[]};const n=overrideCallbacks(s,t);pushOrConcat(e.before,splitNewlines(invokeCallbackWithFallback(n,"beforeLabel",this,t)));pushOrConcat(e.lines,invokeCallbackWithFallback(n,"label",this,t));pushOrConcat(e.after,splitNewlines(invokeCallbackWithFallback(n,"afterLabel",this,t)));i.push(e)}));return i}getAfterBody(t,e){return getBeforeAfterBodyLines(invokeCallbackWithFallback(e.callbacks,"afterBody",this,t))}getFooter(t,e){const{callbacks:s}=e;const i=invokeCallbackWithFallback(s,"beforeFooter",this,t);const n=invokeCallbackWithFallback(s,"footer",this,t);const o=invokeCallbackWithFallback(s,"afterFooter",this,t);let a=[];a=pushOrConcat(a,splitNewlines(i));a=pushOrConcat(a,splitNewlines(n));a=pushOrConcat(a,splitNewlines(o));return a}_createItems(t){const e=this._active;const s=this.chart.data;const i=[];const n=[];const o=[];let a=[];let r,l;for(r=0,l=e.length;r<l;++r)a.push(createTooltipItem(this.chart,e[r]));t.filter&&(a=a.filter(((e,i,n)=>t.filter(e,i,n,s))));t.itemSort&&(a=a.sort(((e,i)=>t.itemSort(e,i,s))));R(a,(e=>{const s=overrideCallbacks(t.callbacks,e);i.push(invokeCallbackWithFallback(s,"labelColor",this,e));n.push(invokeCallbackWithFallback(s,"labelPointStyle",this,e));o.push(invokeCallbackWithFallback(s,"labelTextColor",this,e))}));this.labelColors=i;this.labelPointStyles=n;this.labelTextColors=o;this.dataPoints=a;return a}update(t,e){const s=this.options.setContext(this.getContext());const i=this._active;let n;let o=[];if(i.length){const t=Pe[s.position].call(this,i,this._eventPosition);o=this._createItems(s);this.title=this.getTitle(o,s);this.beforeBody=this.getBeforeBody(o,s);this.body=this.getBody(o,s);this.afterBody=this.getAfterBody(o,s);this.footer=this.getFooter(o,s);const e=this._size=getTooltipSize(this,s);const a=Object.assign({},t,e);const r=determineAlignment(this.chart,s,a);const l=getBackgroundPoint(s,a,r,this.chart);this.xAlign=r.xAlign;this.yAlign=r.yAlign;n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else this.opacity!==0&&(n={opacity:0});this._tooltipItems=o;this.$context=void 0;n&&this._resolveAnimations().update(this,n);t&&s.external&&s.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,s,i){const n=this.getCaretPosition(t,s,i);e.lineTo(n.x1,n.y1);e.lineTo(n.x2,n.y2);e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,s){const{xAlign:i,yAlign:n}=this;const{caretSize:o,cornerRadius:a}=s;const{topLeft:r,topRight:l,bottomLeft:c,bottomRight:h}=Tt(a);const{x:d,y:u}=t;const{width:g,height:f}=e;let p,m,x,b,_,y;if(n==="center"){_=u+f/2;if(i==="left"){p=d;m=p-o;b=_+o;y=_-o}else{p=d+g;m=p+o;b=_-o;y=_+o}x=p}else{m=i==="left"?d+Math.max(r,c)+o:i==="right"?d+g-Math.max(l,h)-o:this.caretX;if(n==="top"){b=u;_=b-o;p=m-o;x=m+o}else{b=u+f;_=b+o;p=m+o;x=m-o}y=b}return{x1:p,x2:m,x3:x,y1:b,y2:_,y3:y}}drawTitle(t,e,s){const i=this.title;const n=i.length;let o,a,r;if(n){const l=Rt(s.rtl,this.x,this.width);t.x=getAlignedX(this,s.titleAlign,s);e.textAlign=l.textAlign(s.titleAlign);e.textBaseline="middle";o=j(s.titleFont);a=s.titleSpacing;e.fillStyle=s.titleColor;e.font=o.string;for(r=0;r<n;++r){e.fillText(i[r],l.x(t.x),t.y+o.lineHeight/2);t.y+=o.lineHeight+a;r+1===n&&(t.y+=s.titleMarginBottom-a)}}}_drawColorBox(t,e,s,i,o){const a=this.labelColors[s];const r=this.labelPointStyles[s];const{boxHeight:l,boxWidth:c}=o;const h=j(o.bodyFont);const d=getAlignedX(this,"left",o);const u=i.x(d);const g=l<h.lineHeight?(h.lineHeight-l)/2:0;const f=e.y+g;if(o.usePointStyle){const e={radius:Math.min(c,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1};const s=i.leftForLtr(u,c)+c/2;const n=f+l/2;t.strokeStyle=o.multiKeyBackground;t.fillStyle=o.multiKeyBackground;At(t,e,s,n);t.strokeStyle=a.borderColor;t.fillStyle=a.backgroundColor;At(t,e,s,n)}else{t.lineWidth=n(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1;t.strokeStyle=a.borderColor;t.setLineDash(a.borderDash||[]);t.lineDashOffset=a.borderDashOffset||0;const e=i.leftForLtr(u,c);const s=i.leftForLtr(i.xPlus(u,1),c-2);const r=Tt(a.borderRadius);if(Object.values(r).some((t=>t!==0))){t.beginPath();t.fillStyle=o.multiKeyBackground;Ot(t,{x:e,y:f,w:c,h:l,radius:r});t.fill();t.stroke();t.fillStyle=a.backgroundColor;t.beginPath();Ot(t,{x:s,y:f+1,w:c-2,h:l-2,radius:r});t.fill()}else{t.fillStyle=o.multiKeyBackground;t.fillRect(e,f,c,l);t.strokeRect(e,f,c,l);t.fillStyle=a.backgroundColor;t.fillRect(s,f+1,c-2,l-2)}}t.fillStyle=this.labelTextColors[s]}drawBody(t,e,s){const{body:i}=this;const{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:c}=s;const h=j(s.bodyFont);let d=h.lineHeight;let u=0;const g=Rt(s.rtl,this.x,this.width);const fillLineOfText=function(s){e.fillText(s,g.x(t.x+u),t.y+d/2);t.y+=d+n};const f=g.textAlign(o);let p,m,x,b,_,y,v;e.textAlign=o;e.textBaseline="middle";e.font=h.string;t.x=getAlignedX(this,f,s);e.fillStyle=s.bodyColor;R(this.beforeBody,fillLineOfText);u=a&&f!=="right"?o==="center"?l/2+c:l+2+c:0;for(b=0,y=i.length;b<y;++b){p=i[b];m=this.labelTextColors[b];e.fillStyle=m;R(p.before,fillLineOfText);x=p.lines;if(a&&x.length){this._drawColorBox(e,t,b,g,s);d=Math.max(h.lineHeight,r)}for(_=0,v=x.length;_<v;++_){fillLineOfText(x[_]);d=h.lineHeight}R(p.after,fillLineOfText)}u=0;d=h.lineHeight;R(this.afterBody,fillLineOfText);t.y-=n}drawFooter(t,e,s){const i=this.footer;const n=i.length;let o,a;if(n){const r=Rt(s.rtl,this.x,this.width);t.x=getAlignedX(this,s.footerAlign,s);t.y+=s.footerMarginTop;e.textAlign=r.textAlign(s.footerAlign);e.textBaseline="middle";o=j(s.footerFont);e.fillStyle=s.footerColor;e.font=o.string;for(a=0;a<n;++a){e.fillText(i[a],r.x(t.x),t.y+o.lineHeight/2);t.y+=o.lineHeight+s.footerSpacing}}}drawBackground(t,e,s,i){const{xAlign:n,yAlign:o}=this;const{x:a,y:r}=t;const{width:l,height:c}=s;const{topLeft:h,topRight:d,bottomLeft:u,bottomRight:g}=Tt(i.cornerRadius);e.fillStyle=i.backgroundColor;e.strokeStyle=i.borderColor;e.lineWidth=i.borderWidth;e.beginPath();e.moveTo(a+h,r);o==="top"&&this.drawCaret(t,e,s,i);e.lineTo(a+l-d,r);e.quadraticCurveTo(a+l,r,a+l,r+d);o==="center"&&n==="right"&&this.drawCaret(t,e,s,i);e.lineTo(a+l,r+c-g);e.quadraticCurveTo(a+l,r+c,a+l-g,r+c);o==="bottom"&&this.drawCaret(t,e,s,i);e.lineTo(a+u,r+c);e.quadraticCurveTo(a,r+c,a,r+c-u);o==="center"&&n==="left"&&this.drawCaret(t,e,s,i);e.lineTo(a,r+h);e.quadraticCurveTo(a,r,a+h,r);e.closePath();e.fill();i.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart;const s=this.$animations;const i=s&&s.x;const n=s&&s.y;if(i||n){const s=Pe[t.position].call(this,this._active,this._eventPosition);if(!s)return;const o=this._size=getTooltipSize(this,t);const a=Object.assign({},s,this._size);const r=determineAlignment(e,t,a);const l=getBackgroundPoint(t,a,r,e);if(i._to!==l.x||n._to!==l.y){this.xAlign=r.xAlign;this.yAlign=r.yAlign;this.width=o.width;this.height=o.height;this.caretX=s.x;this.caretY=s.y;this._resolveAnimations().update(this,l)}}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let s=this.opacity;if(!s)return;this._updateAnimationTarget(e);const i={width:this.width,height:this.height};const n={x:this.x,y:this.y};s=Math.abs(s)<.001?0:s;const o=I(e.padding);const a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;if(e.enabled&&a){t.save();t.globalAlpha=s;this.drawBackground(n,t,i,e);Bt(t,e.textDirection);n.y+=o.top;this.drawTitle(n,t,e);this.drawBody(n,t,e);this.drawFooter(n,t,e);Vt(t,e.textDirection);t.restore()}}getActiveElements(){return this._active||[]}setActiveElements(t,e){const s=this._active;const i=t.map((({datasetIndex:t,index:e})=>{const s=this.chart.getDatasetMeta(t);if(!s)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:s.data[e],index:e}}));const n=!xt(s,i);const o=this._positionChanged(i,e);if(n||o){this._active=i;this._eventPosition=e;this._ignoreReplayEvents=true;this.update(true)}}handleEvent(t,e,s=true){if(e&&this._ignoreReplayEvents)return false;this._ignoreReplayEvents=false;const i=this.options;const n=this._active||[];const o=this._getActiveElements(t,n,e,s);const a=this._positionChanged(o,t);const r=e||!xt(o,n)||a;if(r){this._active=o;if(i.enabled||i.external){this._eventPosition={x:t.x,y:t.y};this.update(true,e)}}return r}_getActiveElements(t,e,s,i){const n=this.options;if(t.type==="mouseout")return[];if(!i)return e.filter((t=>this.chart.data.datasets[t.datasetIndex]&&this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)!==void 0));const o=this.chart.getElementsAtEventForMode(t,n.mode,n,s);n.reverse&&o.reverse();return o}_positionChanged(t,e){const{caretX:s,caretY:i,options:n}=this;const o=Pe[n.position].call(this,t,e);return o!==false&&(s!==o.x||i!==o.y)}}var Le={id:"tooltip",_element:Tooltip,positioners:Pe,afterInit(t,e,s){s&&(t.tooltip=new Tooltip({chart:t,options:s}))},beforeUpdate(t,e,s){t.tooltip&&t.tooltip.initialize(s)},reset(t,e,s){t.tooltip&&t.tooltip.initialize(s)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const s={tooltip:e};if(t.notifyPlugins("beforeTooltipDraw",{...s,cancelable:true})===false)return;e.draw(t.ctx);t.notifyPlugins("afterTooltipDraw",s)}},afterEvent(t,e){if(t.tooltip){const s=e.replay;t.tooltip.handleEvent(e.event,s,e.inChartArea)&&(e.changed=true)}},defaults:{enabled:true,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:true,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Ae},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:t=>t!=="filter"&&t!=="itemSort"&&t!=="external",_indexable:false,callbacks:{_scriptable:false,_indexable:false},animation:{_fallback:false},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};var Te=Object.freeze({__proto__:null,Colors:ve,Decimation:ke,Filler:Me,Legend:Se,SubTitle:Ce,Title:we,Tooltip:Le});const addIfString=(t,e,s,i)=>{if(typeof e==="string"){s=t.push(e)-1;i.unshift({index:s,label:e})}else isNaN(e)&&(s=null);return s};function findOrAddLabel(t,e,s,i){const n=t.indexOf(e);if(n===-1)return addIfString(t,e,s,i);const o=t.lastIndexOf(e);return n!==o?s:n}const validIndex=(t,e)=>t===null?null:G(Math.round(t),0,e);function _getLabelForValue(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}class CategoryScale extends Scale{static id="category";static defaults={ticks:{callback:_getLabelForValue}};constructor(t){super(t);this._startValue=void 0;this._valueRange=0;this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:s,label:i}of e)t[s]===i&&t.splice(s,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(m(t))return null;const s=this.getLabels();e=isFinite(e)&&s[e]===t?e:findOrAddLabel(s,t,h(e,t),this._addedLabels);return validIndex(e,s.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:s,max:i}=this.getMinMax(true);if(this.options.bounds==="ticks"){t||(s=0);e||(i=this.getLabels().length-1)}this.min=s;this.max=i}buildTicks(){const t=this.min;const e=this.max;const s=this.options.offset;const i=[];let n=this.getLabels();n=t===0&&e===n.length-1?n:n.slice(t,e+1);this._valueRange=Math.max(n.length-(s?0:1),1);this._startValue=this.min-(s?.5:0);for(let s=t;s<=e;s++)i.push({value:s});return i}getLabelForValue(t){return _getLabelForValue.call(this,t)}configure(){super.configure();this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){typeof t!=="number"&&(t=this.parse(t));return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function generateTicks$1(t,e){const s=[];const i=1e-14;const{bounds:n,step:o,min:a,max:r,precision:l,count:c,maxTicks:h,maxDigits:d,includeBounds:u}=t;const g=o||1;const f=h-1;const{min:p,max:x}=e;const b=!m(a);const _=!m(r);const y=!m(c);const v=(x-p)/(d+1);let k=Ht((x-p)/f/g)*g;let M,S,w,D;if(k<i&&!b&&!_)return[{value:p},{value:x}];D=Math.ceil(x/k)-Math.floor(p/k);D>f&&(k=Ht(D*k/f/g)*g);if(!m(l)){M=Math.pow(10,l);k=Math.ceil(k*M)/M}if(n==="ticks"){S=Math.floor(p/k)*k;w=Math.ceil(x/k)*k}else{S=p;w=x}if(b&&_&&o&&jt((r-a)/o,k/1e3)){D=Math.round(Math.min((r-a)/k,h));k=(r-a)/D;S=a;w=r}else if(y){S=b?a:S;w=_?r:w;D=c-1;k=(w-S)/D}else{D=(w-S)/k;D=$t(D,Math.round(D),k/1e3)?Math.round(D):Math.ceil(D)}const C=Math.max(Ut(k),Ut(S));M=Math.pow(10,m(l)?C:l);S=Math.round(S*M)/M;w=Math.round(w*M)/M;let P=0;if(b)if(u&&S!==a){s.push({value:a});S<a&&P++;$t(Math.round((S+P*k)*M)/M,a,relativeLabelSize(a,v,t))&&P++}else S<a&&P++;for(;P<D;++P){const t=Math.round((S+P*k)*M)/M;if(_&&t>r)break;s.push({value:t})}_&&u&&w!==r?s.length&&$t(s[s.length-1].value,r,relativeLabelSize(r,v,t))?s[s.length-1].value=r:s.push({value:r}):_&&w!==r||s.push({value:w});return s}function relativeLabelSize(t,e,{horizontal:s,minRotation:i}){const n=v(i);const o=(s?Math.sin(n):Math.cos(n))||.001;const a=.75*e*(""+t).length;return Math.min(e/o,a)}class LinearScaleBase extends Scale{constructor(t){super(t);this.start=void 0;this.end=void 0;this._startValue=void 0;this._endValue=void 0;this._valueRange=0}parse(t,e){return m(t)||(typeof t==="number"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options;const{minDefined:e,maxDefined:s}=this.getUserBounds();let{min:i,max:n}=this;const setMin=t=>i=e?i:t;const setMax=t=>n=s?n:t;if(t){const t=l(i);const e=l(n);t<0&&e<0?setMax(0):t>0&&e>0&&setMin(0)}if(i===n){let e=n===0?1:Math.abs(n*.05);setMax(n+e);t||setMin(i-e)}this.min=i;this.max=n}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:s}=t;let i;if(s){i=Math.ceil(this.max/s)-Math.floor(this.min/s)+1;if(i>1e3){console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${i} ticks. Limiting to 1000.`);i=1e3}}else{i=this.computeTickLimit();e=e||11}e&&(i=Math.min(e,i));return i}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options;const e=t.ticks;let s=this.getTickLimit();s=Math.max(2,s);const i={maxTicks:s,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:e.includeBounds!==false};const n=this._range||this;const o=generateTicks$1(i,n);t.bounds==="ticks"&&Yt(o,this,"value");if(t.reverse){o.reverse();this.start=this.max;this.end=this.min}else{this.start=this.min;this.end=this.max}return o}configure(){const t=this.ticks;let e=this.min;let s=this.max;super.configure();if(this.options.offset&&t.length){const i=(s-e)/Math.max(t.length-1,1)/2;e-=i;s+=i}this._startValue=e;this._endValue=s;this._valueRange=s-e}getLabelForValue(t){return S(t,this.chart.options.locale,this.options.ticks.format)}}class LinearScale extends LinearScaleBase{static id="linear";static defaults={ticks:{callback:Xt.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(true);this.min=r(t)?t:0;this.max=r(e)?e:1;this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal();const e=t?this.width:this.height;const s=v(this.options.ticks.minRotation);const i=(t?Math.sin(s):Math.cos(s))||.001;const n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/i))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const log10Floor=t=>Math.floor(Kt(t));const changeExponent=(t,e)=>Math.pow(10,log10Floor(t)+e);function isMajor(t){const e=t/Math.pow(10,log10Floor(t));return e===1}function steps(t,e,s){const i=Math.pow(10,s);const n=Math.floor(t/i);const o=Math.ceil(e/i);return o-n}function startExp(t,e){const s=e-t;let i=log10Floor(s);while(steps(t,e,i)>10)i++;while(steps(t,e,i)<10)i--;return Math.min(i,log10Floor(t))}function generateTicks(t,{min:e,max:s}){e=Y(t.min,e);const i=[];const n=log10Floor(e);let o=startExp(e,s);let a=o<0?Math.pow(10,Math.abs(o)):1;const r=Math.pow(10,o);const l=n>o?Math.pow(10,n):0;const c=Math.round((e-l)*a)/a;const h=Math.floor((e-l)/r/10)*r*10;let d=Math.floor((c-h)/Math.pow(10,o));let u=Y(t.min,Math.round((l+h+d*Math.pow(10,o))*a)/a);while(u<s){i.push({value:u,major:isMajor(u),significand:d});d>=10?d=d<15?15:20:d++;if(d>=20){o++;d=2;a=o>=0?1:a}u=Math.round((l+h+d*Math.pow(10,o))*a)/a}const g=Y(t.max,u);i.push({value:g,major:isMajor(g),significand:d});return i}class LogarithmicScale extends Scale{static id="logarithmic";static defaults={ticks:{callback:Xt.formatters.logarithmic,major:{enabled:true}}};constructor(t){super(t);this.start=void 0;this.end=void 0;this._startValue=void 0;this._valueRange=0}parse(t,e){const s=LinearScaleBase.prototype.parse.apply(this,[t,e]);if(s!==0)return r(s)&&s>0?s:null;this._zero=true}determineDataLimits(){const{min:t,max:e}=this.getMinMax(true);this.min=r(t)?Math.max(0,t):null;this.max=r(e)?Math.max(0,e):null;this.options.beginAtZero&&(this._zero=true);this._zero&&this.min!==this._suggestedMin&&!r(this._userMin)&&(this.min=t===changeExponent(this.min,0)?changeExponent(this.min,-1):changeExponent(this.min,0));this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let s=this.min;let i=this.max;const setMin=e=>s=t?s:e;const setMax=t=>i=e?i:t;if(s===i)if(s<=0){setMin(1);setMax(10)}else{setMin(changeExponent(s,-1));setMax(changeExponent(i,1))}s<=0&&setMin(changeExponent(i,-1));i<=0&&setMax(changeExponent(s,1));this.min=s;this.max=i}buildTicks(){const t=this.options;const e={min:this._userMin,max:this._userMax};const s=generateTicks(e,this);t.bounds==="ticks"&&Yt(s,this,"value");if(t.reverse){s.reverse();this.start=this.max;this.end=this.min}else{this.start=this.min;this.end=this.max}return s}getLabelForValue(t){return t===void 0?"0":S(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure();this._startValue=Kt(t);this._valueRange=Kt(this.max)-Kt(t)}getPixelForValue(t){t!==void 0&&t!==0||(t=this.min);return t===null||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(Kt(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function getTickBackdropHeight(t){const e=t.ticks;if(e.display&&t.display){const t=I(e.backdropPadding);return h(e.font&&e.font.size,o.font.size)+t.height}return 0}function measureLabelSize(t,e,s){s=a(s)?s:[s];return{w:Gt(t,e.string,s),h:s.length*e.lineHeight}}function determineLimits(t,e,s,i,n){return t===i||t===n?{start:e-s/2,end:e+s/2}:t<i||t>n?{start:e-s,end:e}:{start:e,end:e+s}}function fitWithPointLabels(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom};const s=Object.assign({},e);const i=[];const n=[];const o=t._pointLabels.length;const a=t.options.pointLabels;const r=a.centerPointLabels?y/o:0;for(let l=0;l<o;l++){const o=a.setContext(t.getPointLabelContext(l));n[l]=o.padding;const c=t.getPointPosition(l,t.drawingArea+n[l],r);const h=j(o.font);const d=measureLabelSize(t.ctx,h,t._pointLabels[l]);i[l]=d;const u=It(t.getIndexAngle(l)+r);const g=Math.round(q(u));const f=determineLimits(g,c.x,d.w,0,180);const p=determineLimits(g,c.y,d.h,90,270);updateLimits(s,e,u,f,p)}t.setCenterPoint(e.l-s.l,s.r-e.r,e.t-s.t,s.b-e.b);t._pointLabelItems=buildPointLabelItems(t,i,n)}function updateLimits(t,e,s,i,n){const o=Math.abs(Math.sin(s));const a=Math.abs(Math.cos(s));let r=0;let l=0;if(i.start<e.l){r=(e.l-i.start)/o;t.l=Math.min(t.l,e.l-r)}else if(i.end>e.r){r=(i.end-e.r)/o;t.r=Math.max(t.r,e.r+r)}if(n.start<e.t){l=(e.t-n.start)/a;t.t=Math.min(t.t,e.t-l)}else if(n.end>e.b){l=(n.end-e.b)/a;t.b=Math.max(t.b,e.b+l)}}function createPointLabelItem(t,e,s){const i=t.drawingArea;const{extra:n,additionalAngle:o,padding:a,size:r}=s;const l=t.getPointPosition(e,i+n+a,o);const c=Math.round(q(It(l.angle+_)));const h=yForAngle(l.y,r.h,c);const d=getTextAlignForAngle(c);const u=leftForTextAlign(l.x,r.w,d);return{visible:true,x:l.x,y:h,textAlign:d,left:u,top:h,right:u+r.w,bottom:h+r.h}}function isNotOverlapped(t,e){if(!e)return true;const{left:s,top:i,right:n,bottom:o}=t;const a=T({x:s,y:i},e)||T({x:s,y:o},e)||T({x:n,y:i},e)||T({x:n,y:o},e);return!a}function buildPointLabelItems(t,e,s){const i=[];const n=t._pointLabels.length;const o=t.options;const{centerPointLabels:a,display:r}=o.pointLabels;const l={extra:getTickBackdropHeight(o)/2,additionalAngle:a?y/n:0};let c;for(let o=0;o<n;o++){l.padding=s[o];l.size=e[o];const n=createPointLabelItem(t,o,l);i.push(n);if(r==="auto"){n.visible=isNotOverlapped(n,c);n.visible&&(c=n)}}return i}function getTextAlignForAngle(t){return t===0||t===180?"center":t<180?"left":"right"}function leftForTextAlign(t,e,s){s==="right"?t-=e:s==="center"&&(t-=e/2);return t}function yForAngle(t,e,s){s===90||s===270?t-=e/2:(s>270||s<90)&&(t-=e);return t}function drawPointLabelBox(t,e,s){const{left:i,top:n,right:o,bottom:a}=s;const{backdropColor:r}=e;if(!m(r)){const s=Tt(e.borderRadius);const l=I(e.backdropPadding);t.fillStyle=r;const c=i-l.left;const h=n-l.top;const d=o-i+l.width;const u=a-n+l.height;if(Object.values(s).some((t=>t!==0))){t.beginPath();Ot(t,{x:c,y:h,w:d,h:u,radius:s});t.fill()}else t.fillRect(c,h,d,u)}}function drawPointLabels(t,e){const{ctx:s,options:{pointLabels:i}}=t;for(let n=e-1;n>=0;n--){const e=t._pointLabelItems[n];if(!e.visible)continue;const o=i.setContext(t.getPointLabelContext(n));drawPointLabelBox(s,o,e);const a=j(o.font);const{x:r,y:l,textAlign:c}=e;et(s,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:c,textBaseline:"middle"})}}function pathRadiusLine(t,e,s,i){const{ctx:n}=t;if(s)n.arc(t.xCenter,t.yCenter,e,0,x);else{let s=t.getPointPosition(0,e);n.moveTo(s.x,s.y);for(let o=1;o<i;o++){s=t.getPointPosition(o,e);n.lineTo(s.x,s.y)}}}function drawRadiusLine(t,e,s,i,n){const o=t.ctx;const a=e.circular;const{color:r,lineWidth:l}=e;if((a||i)&&r&&l&&!(s<0)){o.save();o.strokeStyle=r;o.lineWidth=l;o.setLineDash(n.dash);o.lineDashOffset=n.dashOffset;o.beginPath();pathRadiusLine(t,s,a,i);o.closePath();o.stroke();o.restore()}}function createPointLabelContext(t,e,s){return c(t,{label:s,index:e,type:"pointLabel"})}class RadialLinearScale extends LinearScaleBase{static id="radialLinear";static defaults={display:true,animate:true,position:"chartArea",angleLines:{display:true,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:false},startAngle:0,ticks:{showLabelBackdrop:true,callback:Xt.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:true,font:{size:10},callback(t){return t},padding:5,centerPointLabels:false}};static defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};static descriptors={angleLines:{_fallback:"grid"}};constructor(t){super(t);this.xCenter=void 0;this.yCenter=void 0;this.drawingArea=void 0;this._pointLabels=[];this._pointLabelItems=[]}setDimensions(){const t=this._padding=I(getTickBackdropHeight(this.options)/2);const e=this.width=this.maxWidth-t.width;const s=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left);this.yCenter=Math.floor(this.top+s/2+t.top);this.drawingArea=Math.floor(Math.min(e,s)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(false);this.min=r(t)&&!isNaN(t)?t:0;this.max=r(e)&&!isNaN(e)?e:0;this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/getTickBackdropHeight(this.options))}generateTickLabels(t){LinearScaleBase.prototype.generateTickLabels.call(this,t);this._pointLabels=this.getLabels().map(((t,e)=>{const s=X(this.options.pointLabels.callback,[t,e],this);return s||s===0?s:""})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?fitWithPointLabels(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,s,i){this.xCenter+=Math.floor((t-e)/2);this.yCenter+=Math.floor((s-i)/2);this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,s,i))}getIndexAngle(t){const e=x/(this._pointLabels.length||1);const s=this.options.startAngle||0;return It(t*e+v(s))}getDistanceFromCenterForValue(t){if(m(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(m(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const s=e[t];return createPointLabelContext(this.getContext(),t,s)}}getPointPosition(t,e,s=0){const i=this.getIndexAngle(t)-_+s;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter,angle:i}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:s,right:i,bottom:n}=this._pointLabelItems[t];return{left:e,top:s,right:i,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const s=this.ctx;s.save();s.beginPath();pathRadiusLine(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length);s.closePath();s.fillStyle=t;s.fill();s.restore()}}drawGrid(){const t=this.ctx;const e=this.options;const{angleLines:s,grid:i,border:n}=e;const o=this._pointLabels.length;let a,r,l;e.pointLabels.display&&drawPointLabels(this,o);i.display&&this.ticks.forEach(((t,e)=>{if(e!==0||e===0&&this.min<0){r=this.getDistanceFromCenterForValue(t.value);const s=this.getContext(e);const a=i.setContext(s);const l=n.setContext(s);drawRadiusLine(this,a,r,o,l)}}));if(s.display){t.save();for(a=o-1;a>=0;a--){const i=s.setContext(this.getPointLabelContext(a));const{color:n,lineWidth:o}=i;if(o&&n){t.lineWidth=o;t.strokeStyle=n;t.setLineDash(i.borderDash);t.lineDashOffset=i.borderDashOffset;r=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max);l=this.getPointPosition(a,r);t.beginPath();t.moveTo(this.xCenter,this.yCenter);t.lineTo(l.x,l.y);t.stroke()}}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx;const e=this.options;const s=e.ticks;if(!s.display)return;const i=this.getIndexAngle(0);let n,o;t.save();t.translate(this.xCenter,this.yCenter);t.rotate(i);t.textAlign="center";t.textBaseline="middle";this.ticks.forEach(((i,a)=>{if(a===0&&this.min>=0&&!e.reverse)return;const r=s.setContext(this.getContext(a));const l=j(r.font);n=this.getDistanceFromCenterForValue(this.ticks[a].value);if(r.showLabelBackdrop){t.font=l.string;o=t.measureText(i.label).width;t.fillStyle=r.backdropColor;const e=I(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}et(t,i.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})}));t.restore()}drawTitle(){}}const Oe={millisecond:{common:true,size:1,steps:1e3},second:{common:true,size:1e3,steps:60},minute:{common:true,size:6e4,steps:60},hour:{common:true,size:36e5,steps:24},day:{common:true,size:864e5,steps:30},week:{common:false,size:6048e5,steps:4},month:{common:true,size:2628e6,steps:12},quarter:{common:false,size:7884e6,steps:4},year:{common:true,size:3154e7}};const Ee=Object.keys(Oe);function sorter(t,e){return t-e}function parse(t,e){if(m(e))return null;const s=t._adapter;const{parser:i,round:n,isoWeekday:o}=t._parseOpts;let a=e;typeof i==="function"&&(a=i(a));r(a)||(a=typeof i==="string"?s.parse(a,i):s.parse(a));if(a===null)return null;n&&(a=n!=="week"||!C(o)&&o!==true?s.startOf(a,n):s.startOf(a,"isoWeek",o));return+a}function determineUnitForAutoTicks(t,e,s,i){const n=Ee.length;for(let o=Ee.indexOf(t);o<n-1;++o){const t=Oe[Ee[o]];const n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((s-e)/(n*t.size))<=i)return Ee[o]}return Ee[n-1]}function determineUnitForFormatting(t,e,s,i,n){for(let o=Ee.length-1;o>=Ee.indexOf(s);o--){const s=Ee[o];if(Oe[s].common&&t._adapter.diff(n,i,s)>=e-1)return s}return Ee[s?Ee.indexOf(s):0]}function determineMajorUnit(t){for(let e=Ee.indexOf(t)+1,s=Ee.length;e<s;++e)if(Oe[Ee[e]].common)return Ee[e]}function addTick(t,e,s){if(s){if(s.length){const{lo:i,hi:n}=qt(s,e);const o=s[i]>=e?s[i]:s[n];t[o]=true}}else t[e]=true}function setMajorTicks(t,e,s,i){const n=t._adapter;const o=+n.startOf(e[0].value,i);const a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,i)){l=s[r];l>=0&&(e[l].major=true)}return e}function ticksFromTimestamps(t,e,s){const i=[];const n={};const o=e.length;let a,r;for(a=0;a<o;++a){r=e[a];n[r]=a;i.push({value:r,major:false})}return o!==0&&s?setMajorTicks(t,i,n,s):i}class TimeScale extends Scale{static id="time";static defaults={bounds:"data",adapters:{},time:{parser:false,unit:false,round:false,isoWeekday:false,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:false,major:{enabled:false}}};constructor(t){super(t);this._cache={data:[],labels:[],all:[]};this._unit="day";this._majorUnit=void 0;this._offsets={};this._normalized=false;this._parseOpts=void 0}init(t,e={}){const s=t.time||(t.time={});const i=this._adapter=new se._date(t.adapters.date);i.init(e);at(s.displayFormats,i.formats());this._parseOpts={parser:s.parser,round:s.round,isoWeekday:s.isoWeekday};super.init(t);this._normalized=e.normalized}parse(t,e){return t===void 0?null:parse(this,t)}beforeLayout(){super.beforeLayout();this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options;const e=this._adapter;const s=t.time.unit||"day";let{min:i,max:n,minDefined:o,maxDefined:a}=this.getUserBounds();function _applyBounds(t){o||isNaN(t.min)||(i=Math.min(i,t.min));a||isNaN(t.max)||(n=Math.max(n,t.max))}if(!o||!a){_applyBounds(this._getLabelBounds());t.bounds==="ticks"&&t.ticks.source==="labels"||_applyBounds(this.getMinMax(false))}i=r(i)&&!isNaN(i)?i:+e.startOf(Date.now(),s);n=r(n)&&!isNaN(n)?n:+e.endOf(Date.now(),s)+1;this.min=Math.min(i,n-1);this.max=Math.max(i+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY;let s=Number.NEGATIVE_INFINITY;if(t.length){e=t[0];s=t[t.length-1]}return{min:e,max:s}}buildTicks(){const t=this.options;const e=t.time;const s=t.ticks;const i=s.source==="labels"?this.getLabelTimestamps():this._generate();if(t.bounds==="ticks"&&i.length){this.min=this._userMin||i[0];this.max=this._userMax||i[i.length-1]}const n=this.min;const o=this.max;const a=Jt(i,n,o);this._unit=e.unit||(s.autoSkip?determineUnitForAutoTicks(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):determineUnitForFormatting(this,a.length,e.minUnit,this.min,this.max));this._majorUnit=s.major.enabled&&this._unit!=="year"?determineMajorUnit(this._unit):void 0;this.initOffsets(i);t.reverse&&a.reverse();return ticksFromTimestamps(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e=0;let s=0;let i,n;if(this.options.offset&&t.length){i=this.getDecimalForValue(t[0]);e=t.length===1?1-i:(this.getDecimalForValue(t[1])-i)/2;n=this.getDecimalForValue(t[t.length-1]);s=t.length===1?n:(n-this.getDecimalForValue(t[t.length-2]))/2}const o=t.length<3?.5:.25;e=G(e,0,o);s=G(s,0,o);this._offsets={start:e,end:s,factor:1/(e+1+s)}}_generate(){const t=this._adapter;const e=this.min;const s=this.max;const i=this.options;const n=i.time;const o=n.unit||determineUnitForAutoTicks(n.minUnit,e,s,this._getLabelCapacity(e));const a=h(i.ticks.stepSize,1);const r=o==="week"&&n.isoWeekday;const l=C(r)||r===true;const c={};let d=e;let u,g;l&&(d=+t.startOf(d,"isoWeek",r));d=+t.startOf(d,l?"day":o);if(t.diff(s,e,o)>1e5*a)throw new Error(e+" and "+s+" are too far apart with stepSize of "+a+" "+o);const f=i.ticks.source==="data"&&this.getDataTimestamps();for(u=d,g=0;u<s;u=+t.add(u,a,o),g++)addTick(c,u,f);u!==s&&i.bounds!=="ticks"&&g!==1||addTick(c,u,f);return Object.keys(c).sort(sorter).map((t=>+t))}getLabelForValue(t){const e=this._adapter;const s=this.options.time;return s.tooltipFormat?e.format(t,s.tooltipFormat):e.format(t,s.displayFormats.datetime)}format(t,e){const s=this.options;const i=s.time.displayFormats;const n=this._unit;const o=e||i[n];return this._adapter.format(t,o)}_tickFormatFunction(t,e,s,i){const n=this.options;const o=n.ticks.callback;if(o)return X(o,[t,e,s],this);const a=n.time.displayFormats;const r=this._unit;const l=this._majorUnit;const c=r&&a[r];const h=l&&a[l];const d=s[e];const u=l&&h&&d&&d.major;return this._adapter.format(t,i||(u?h:c))}generateTickLabels(t){let e,s,i;for(e=0,s=t.length;e<s;++e){i=t[e];i.label=this._tickFormatFunction(i.value,e,t)}}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets;const s=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+s)*e.factor)}getValueForPixel(t){const e=this._offsets;const s=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+s*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks;const s=this.ctx.measureText(t).width;const i=v(this.isHorizontal()?e.maxRotation:e.minRotation);const n=Math.cos(i);const o=Math.sin(i);const a=this._resolveTickFontOptions(0).size;return{w:s*n+a*o,h:s*o+a*n}}_getLabelCapacity(t){const e=this.options.time;const s=e.displayFormats;const i=s[e.unit]||s.millisecond;const n=this._tickFormatFunction(t,0,ticksFromTimestamps(this,[t],this._majorUnit),i);const o=this._getLabelSize(n);const a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[];let e,s;if(t.length)return t;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(e=0,s=i.length;e<s;++e)t=t.concat(i[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,s;if(t.length)return t;const i=this.getLabels();for(e=0,s=i.length;e<s;++e)t.push(parse(this,i[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return p(t.sort(sorter))}}function interpolate(t,e,s){let i=0;let n=t.length-1;let o,a,r,l;if(s){e>=t[i].pos&&e<=t[n].pos&&({lo:i,hi:n}=L(t,"pos",e));({pos:o,time:r}=t[i]);({pos:a,time:l}=t[n])}else{e>=t[i].time&&e<=t[n].time&&({lo:i,hi:n}=L(t,"time",e));({time:o,pos:r}=t[i]);({time:a,pos:l}=t[n])}const c=a-o;return c?r+(l-r)*(e-o)/c:r}class TimeSeriesScale extends TimeScale{static id="timeseries";static defaults=TimeScale.defaults;constructor(t){super(t);this._table=[];this._minPos=void 0;this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable();const e=this._table=this.buildLookupTable(t);this._minPos=interpolate(e,this.min);this._tableRange=interpolate(e,this.max)-this._minPos;super.initOffsets(t)}buildLookupTable(t){const{min:e,max:s}=this;const i=[];const n=[];let o,a,r,l,c;for(o=0,a=t.length;o<a;++o){l=t[o];l>=e&&l<=s&&i.push(l)}if(i.length<2)return[{time:e,pos:0},{time:s,pos:1}];for(o=0,a=i.length;o<a;++o){c=i[o+1];r=i[o-1];l=i[o];Math.round((c+r)/2)!==l&&n.push({time:l,pos:o/(a-1)})}return n}_generate(){const t=this.min;const e=this.max;let s=super.getDataTimestamps();s.includes(t)&&s.length||s.splice(0,0,t);s.includes(e)&&s.length!==1||s.push(e);return s.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps();const s=this.getLabelTimestamps();t=e.length&&s.length?this.normalize(e.concat(s)):e.length?e:s;t=this._cache.all=t;return t}getDecimalForValue(t){return(interpolate(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets;const s=this.getDecimalForPixel(t)/e.factor-e.end;return interpolate(this._table,s*this._tableRange+this._minPos,true)}}var Ie=Object.freeze({__proto__:null,CategoryScale:CategoryScale,LinearScale:LinearScale,LogarithmicScale:LogarithmicScale,RadialLinearScale:RadialLinearScale,TimeScale:TimeScale,TimeSeriesScale:TimeSeriesScale});const Re=[ee,be,Te,Ie];export{Animation,Animations,ArcElement,BarController,BarElement,BasePlatform,BasicPlatform,BubbleController,CategoryScale,Chart,ve as Colors,DatasetController,ke as Decimation,DomPlatform,DoughnutController,Element,Me as Filler,ie as Interaction,Se as Legend,LineController,LineElement,LinearScale,LogarithmicScale,PieController,PointElement,PolarAreaController,RadarController,RadialLinearScale,Scale,ScatterController,Ce as SubTitle,Xt as Ticks,TimeScale,TimeSeriesScale,we as Title,Le as Tooltip,se as _adapters,_detectPlatform,Zt as animator,ee as controllers,o as defaults,be as elements,oe as layouts,Te as plugins,Re as registerables,de as registry,Ie as scales};

